---
title: "ArchR_cell_line_mixing"
author: "Siyuan Luo"
date: "2022-11-02"
output:
  html_document:
    df_print: paged
    toc: TRUE
    #toc_float: TRUE
    theme: default
# editor_options:
#   chunk_output_type: console
editor_options: 
  chunk_output_type: inline
---

```{r setup, include=FALSE}
# include the code in the knitted document
knitr::opts_chunk$set(echo = TRUE)
```

# Dependancies
```{r, eval=FALSE}
if (!requireNamespace("devtools", quietly = TRUE)) install.packages("devtools")
if (!requireNamespace("BiocManager", quietly = TRUE)) install.packages("BiocManager")
# devtools::install_github("GreenleafLab/ArchR", ref="master", repos = BiocManager::repositories())
devtools::install_github("GreenleafLab/ArchR", ref="dev_filterChr", repos = BiocManager::repositories())
ArchR::installExtraPackages()
```

‘textshaping’,‘ragg’,‘pkgdown’ not yet installed

```{r, message=FALSE}
# detach("package:ArchR", unload=TRUE)
library(ArchR)
# library(magrittr) # needs to be run every time you start R and want to use %>%
library(dplyr)
library("BSgenome.Hsapiens.UCSC.hg19")
```

```{r, eval=FALSE}
# computer specific settings
software_dir <- "/home/siluo/Software/"
software_dir <- "/home/siluo/softwares/"
```

```{r,eval=FALSE}
proj_dir <- "/home/siluo/public/SiyuanLuo/projects/benchmark/"
```

```{r}
setwd(paste0(proj_dir,"scripts/data_cleaning/Cell_line_mix"))
```

```{r}
addArchRGenome("hg19")
addArchRThreads(threads = 16)
```

```{r}
data_name <- 'Cell_line_mixing/'
input_dir <- '/home/siluo/public/SiyuanLuo/projects/benchmark/raw_data/'
output_dir <- '/home/siluo/public/SiyuanLuo/projects/benchmark/cleaned_data/'
```

```{r}
inputFiles <- c(paste0(input_dir, data_name, "GSE162690_CellLine_LowLoading.fragments.tsv.gz"), paste0(input_dir, data_name, "GSE162690_CellLine_HighLoading.fragments.tsv.gz"))
names(inputFiles) <- c("CellLine_LowLoading","CellLine_HighLoading")
```

```{r}
inputFiles <- c(paste0(input_dir, data_name, "GSE162690_CellLine_LowLoading.fragments.tsv.gz"))
names(inputFiles) <- c("CellLine_LowLoading")
```
# Creat ArchR project
```{r}
# create arrow file, per-cell QC
ArrowFiles <- createArrowFiles(
  inputFiles = inputFiles,
  sampleNames = names(inputFiles),
  minTSS = 0, 
  minFrags = 0, 
  addTileMat = FALSE,
  addGeneScoreMat = FALSE,
  force = FALSE
)
```

```{r}
a <- c("CellLine_HighLoading.arrow", "CellLine_LowLoading.arrow" )
```

```{r}
ArrowFiles
```

```{r}
# create archR project
projCellMix <- ArchRProject(
  ArrowFiles = ArrowFiles, 
  outputDirectory = "projCellMix",
  copyArrows = TRUE #This is recommended so that if you modify the Arrow files you have an original copy for later usage.
)
```


# Do per-cell QC
```{r}
# Subsetting by per cell QC
th_tss <- 1
th_nfrag <- 1000
idxPass1 <- projCellMix$TSSEnrichment >= th_tss
idxPass2 <- projCellMix$nFrags >= th_nfrag
table(idxPass1)
table(idxPass2)
cellsPass <- projCellMix$cellNames[idxPass1 & idxPass2]
saveArchRProject(ArchRProj = projCellMix, load = FALSE) 
# projCellMix <-loadArchRProject(path = "projCellMix", force = FALSE, showLogo = TRUE)

df_QC <- data.frame(rownames(getCellColData(projCellMix)))
colnames(df_QC) <- c("cell_id")
rownames(df_QC) <- df_QC$cell_id
df_QC["QC"] <- "filtered_out"

projCellMix2 <- projCellMix[cellsPass, ]

df_QC[rownames(df_QC) %in%rownames(getCellColData(projCellMix2)),"QC"] <- "doublet"
```

```{r}
# add Tile matrix
addTileMatrix(
  input = projCellMix2,
  chromSizes = if (inherits(projCellMix2, "ArchRProject")) getChromSizes(projCellMix2) else NULL,
  blacklist = if (inherits(projCellMix2, "ArchRProject")) getBlacklist(projCellMix2) else NULL,
  tileSize = 500,
  binarize = TRUE,
  excludeChr = c("chrM", "chrY"),
  threads = getArchRThreads(),
  parallelParam = NULL,
  force = TRUE,
  logFile = createLogFile("addTileMatrix")
)
```

```{r}
# identify doublets
projCellMix2 <- addDoubletScores(
  input = projCellMix2,
  k = 50, #Refers to how many cells near a "pseudo-doublet" to count.
  knnMethod = "UMAP", #Refers to the embedding to use for nearest neighbor search with doublet projection.
  LSIMethod = 1
)

getAvailableMatrices(projCellMix2)
```

## Remove doublets
```{r}
# remove doublets
projCellMix2 <- filterDoublets(projCellMix2, filterRatio = 3)

# save the project
projCellMix2 <- saveArchRProject(ArchRProj = projCellMix2, 
                                 outputDirectory = "projCellMix2",
                                 load=TRUE) # load=TRUE when one want to overwrite the original files
```

```{r}
# plot QC metrics
df <- getCellColData(projCellMix2, select = c("log10(nFrags)", "TSSEnrichment"))
p1 <- ggPoint(
  x = df[,1], 
  y = df[,2], 
  colorDensity = TRUE,
  continuousSet = "sambaNight",
  xlabel = "Log10 Unique Fragments",
  ylabel = "TSS Enrichment",
  xlim = c(log10(500), quantile(df[,1], probs = 0.99)),
  ylim = c(0, quantile(df[,2], probs = 0.99))
) + geom_hline(yintercept = 4, lty = "dashed") + geom_vline(xintercept = 3, lty = "dashed")

p2 <- plotGroups(
  ArchRProj = projCellMix2, 
  groupBy = "Sample", 
  colorBy = "cellColData", 
  name = "TSSEnrichment",
  plotAs = "violin",
  alpha = 0.4,
  addBoxPlot = TRUE
)
p3 <- plotGroups(
  ArchRProj = projCellMix2, 
  groupBy = "Sample", 
  colorBy = "cellColData", 
  name = "log10(nFrags)",
  plotAs = "violin",
  alpha = 0.4,
  addBoxPlot = TRUE
)
p4 <- plotFragmentSizes(ArchRProj = projCellMix2)
p5 <- plotTSSEnrichment(ArchRProj = projCellMix2)
# plot to a pdf file
plotPDF(p1,p2,p3,p4,p5, name = "Plot-QC.pdf", ArchRProj = projCellMix2, addDOC = FALSE, width = 5, height = 5)
```

## Output passed cell id
```{r}
df_QC[rownames(df_QC) %in% rownames(getCellColData(projCellMix2)),"QC"] <- "passed"
write.table(df_QC, file='Cell_id_QC_ArchR.txt', sep='\t', quote = FALSE,row.names=FALSE)

# Output only cells passed QC and doublet; the rest are filtered by TSS enrichment score and #unique fragments
```

# Get the feature matrix by iterative LSI
## LSI using tile matrix
```{r}
# dimentional reduction using LSI
## If needed: batch effect correction, estimated LSI

n_iteration <- 4

for (n_LSI in c(30,50,100)) {
  projCellMix2 <- addIterativeLSI(
  ArchRProj = projCellMix2,
  useMatrix = "TileMatrix",
  name = paste0("IterativeLSI_ndim",n_LSI),
  iterations = n_iteration,
  clusterParams = list( #See Seurat::FindClusters
    resolution = c(0.4, 0.6, 0.8, 1),
    sampleCells = 10000,
    n.start = 10
    ),
  varFeatures = 25000,
  dimsToUse = 1:n_LSI,
  scaleDims = TRUE, # by default
  force = TRUE
  )
  
  # output the LSI matrix
  processed_matrix <- 
    getReducedDims(
    ArchRProj = projCellMix2,
    reducedDims = paste0("IterativeLSI_ndim",n_LSI),
    returnMatrix = TRUE,
    scaleDims = FALSE,  # already scaled ?????? check
    dimsToUse = 1:n_LSI,
    corCutOff = 0.75
  )
  
  write.table(processed_matrix, file=paste0('CellMix_IterativeLSI_reducedDims_i',n_iteration,'_ndim',n_LSI,'_TileAsFeatures.txt'), sep='\t', quote = FALSE)
}

saveArchRProject(ArchRProj = projCellMix2, load = FALSE) 

projCellMix3 <- projCellMix2
projCellMix3 <- saveArchRProject(ArchRProj = projCellMix3, 
                                 outputDirectory = "projCellMix3",
                                 load=TRUE)
# # output LSI features (Tiles or Peaks)
# df_LSIFeatures <- projCellMix2@reducedDims$IterativeLSI$LSIFeatures
# write.table(df_LSIFeatures, file=paste0('CellMix_IterativeLSI_features_i',n_iteration,'_n',n_LSI,'_TileAsFeatures.txt'), sep='\t', quote = FALSE)
```

```{r}
# library(Matrix)
# sparse_peak_matrix <- as(peak_matrix, "sparseMatrix")
# writeMM(sparse_peak_matrix,"CellMix_IterativeLSI_i4_n50.mtx")
# projCellMix3 <-loadArchRProject(path = "projCellMix3", force = FALSE, showLogo = FALSE)
```

## Add PeakMatrix and then redo LSI
### Clustering
```{r}
# Clustering
for (n_LSI in c(30,50,100)) {
  projCellMix3 <- addClusters(
    input = projCellMix3,
    reducedDims = paste0("IterativeLSI_ndim",n_LSI),
    method = "Seurat",
    name = paste0("Clusters_ndim",n_LSI),
    resolution = 0.2,
    algorithm = 4,
    dimsToUse = 1:n_LSI,
    force = TRUE
    )

  projCellMix3 <- addUMAP(
    ArchRProj = projCellMix3, 
    reducedDims = paste0("IterativeLSI_ndim",n_LSI),
    name = paste0("UMAP_ndim",n_LSI),
    nNeighbors = 30, 
    minDist = 0.5, 
    metric = "cosine",
    force = TRUE
  )
}
```
```{r}
p1 <- plotEmbedding(ArchRProj = projCellMix3, colorBy = "cellColData", name = "Clusters_ndim30", embedding = "UMAP_ndim30")
p2 <- plotEmbedding(ArchRProj = projCellMix3, colorBy = "cellColData", name = "Clusters_ndim50", embedding = "UMAP_ndim50")
p3 <- plotEmbedding(ArchRProj = projCellMix3, colorBy = "cellColData", name = "Clusters_ndim100", embedding = "UMAP_ndim100")
plotPDF(p1,p2,p3, name = "Plot_UMAP.pdf", ArchRProj = projCellMix3, addDOC = FALSE, width = 5, height = 5)
```
### Peak calling
```{r}
# Adding pseudo-bulk
projCellMix3 <- addGroupCoverages(ArchRProj = projCellMix3, groupBy = "Clusters_ndim50", force = TRUE)

# Calling peaks using MACS2
pathToMacs2 <- paste0(software_dir,"annaconda3/envs/sc_chromatin/bin/macs2")
```

```{r}
projCellMix3 <- addReproduciblePeakSet(
    ArchRProj = projCellMix3, 
    groupBy = "Clusters_ndim50", 
    peakMethod = "Macs2",
    pathToMacs2 = pathToMacs2,
    threads = 10
    )
#"/home/siluo/Software/annaconda3/envs/sc_chromatin/bin/macs2"
#"anaconda3/envs/test/bin/macs2"

# Add insertion matrix
projCellMix3 <- addPeakMatrix(projCellMix3)

# Redo LSI
n_iteration <- 4

for (n_LSI in c(30,50,100)) {
  projCellMix3 <- addIterativeLSI(
  ArchRProj = projCellMix3,
  useMatrix = "PeakMatrix",
  name = paste0("IterativeLSI_peaks_ndim",n_LSI),
  iterations = n_iteration,
  clusterParams = list( #See Seurat::FindClusters
    resolution = c(0.4, 0.6, 0.8, 1),
    sampleCells = 10000,
    n.start = 10,
    algorithm = 4
    ),
  varFeatures = 25000,
  dimsToUse = 1:n_LSI,
  scaleDims = TRUE, # by default
  force = TRUE
  )
  
  # output the LSI matrix
  processed_matrix <- 
    getReducedDims(
    ArchRProj = projCellMix3,
    reducedDims = paste0("IterativeLSI_peaks_ndim",n_LSI),
    returnMatrix = TRUE,
    scaleDims = FALSE,  # already scaled ?????? check
    dimsToUse = 1:n_LSI,
    corCutOff = 0.75
  )
  
  write.table(processed_matrix, file=paste0('CellMix_IterativeLSI_reducedDims_i',n_iteration,'_ndim',n_LSI,'_PeakAsFeatures.txt'), sep='\t', quote = FALSE)
}

saveArchRProject(ArchRProj = projCellMix3, load = FALSE)
# projCellMix3 <- loadArchRProject(path = "projCellMix3", force = FALSE, showLogo = FALSE)
```

### Output the cells that passed QC
```{r}
df <- data.frame(projCellMix3$cellNames)
colnames(df) <- "cell_id"
write.table(df, file='CellMix_ArchR_passed_QC.txt', sep='\t', quote = FALSE)
```

# Check cell barcode overlapping with RDS files
```{r}
fragProj <- loadArchRProject(path = "./projCellMix2", force = FALSE, showLogo = FALSE)
peak_high <- readRDS("../../datasets/GSE162690_CellLine_HighLoading-PeakMatrix-SE.rds")
peak_low <- readRDS("../../datasets/GSE162690_CellLine_LowLoading-PeakMatrix-SE.rds")

colnames(peak_high) <-sub("CellLine_High", "CellLine_HighLoading", colnames(peak_high))
colnames(peak_low) <-sub("CellLine_Low", "CellLine_LowLoading", colnames(peak_low))

sum(colnames(peak_high) %in% fragProj$cellNames)
length(colnames(peak_high))

sum(colnames(peak_low) %in% fragProj$cellNames)
length(colnames(peak_low))

barcodeHigh <- sub("CellLine_HighLoading#", "", colnames(peak_high))
barcodeLow <- sub("CellLine_LowLoading#", "", colnames(peak_low))
sum(barcodeHigh %in% barcodeLow)
```


```{r}
sessionInfo() 
```